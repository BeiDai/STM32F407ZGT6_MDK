 ----------------
 --------------------- IO口模式选择 ------------------------

 http://www.openedv.com/posts/list/32730.htm


（1）GPIO_Mode_AIN 模拟输入 
（2）GPIO_Mode_IN_FLOATING 浮空输入
（3）GPIO_Mode_IPD 下拉输入
（4）GPIO_Mode_IPU 上拉输入
（5）GPIO_Mode_Out_OD 开漏输出
（6）GPIO_Mode_Out_PP 推挽输出
（7）GPIO_Mode_AF_OD 复用开漏输出
（8）GPIO_Mode_AF_PP 复用推挽输出

 在STM32中选用IO模式

（1） 浮空输入_IN_FLOATING ――浮空输入，可以做KEY识别，RX1

（2）带上拉输入_IPU――IO内部上拉电阻输入

（3）带下拉输入_IPD―― IO内部下拉电阻输入

（4） 模拟输入_AIN ――应用ADC模拟输入，或者低功耗下省电

（5）开漏输出_OUT_OD ――IO输出0接GND，IO输出1，悬空，需要外接上拉电阻，才能实现
     输出高电平。当输出为1时，IO口的状态由上拉电阻拉高电平，但由于是开漏输出模式，
     这样IO口也就可以由外部电路改变为低电平或不变。可以读IO输入电平变化，实现C51
     的IO双向功能

（6）推挽输出_OUT_PP ――IO输出0-接GND， IO输出1 -接VCC，读输入值是未知的

（7）复用功能的推挽输出_AF_PP ――片内外设功能（I2C的SCL,SDA）

（8）复用功能的开漏输出_AF_OD――片内外设功能（TX1,MOSI,MISO.SCK.SS）

 --------------------- IO口速度选择 ------------------------

       (如果一个信号的频率超过了驱动电路的响应速度，就有可能信号失真。失真因素？)

	关键是： GPIO的引脚速度跟应用相匹配，速度配置越高，噪声越大，功耗越大

	带宽速度高的驱动器耗电大、噪声也大，带宽低的驱动器耗电小、噪声也小

  	比如：

	①　USART串口，若最大波特率只需115.2k，那用2M的速度就够了，既省电也噪声小。

	②　I2C接口，若使用400k波特率，若想把余量留大些，可以选用10M的GPIO引脚速度。

	③　SPI接口，若使用18M或9M波特率，需要选用50M的GPIO的引脚速度。

 ---------------------  重映射功能  ------------------------

	- 晶体振荡器的引脚在不接晶体时，可以作为普通I/O口

	- CAN模块； - JTAG调试接口；- 大部分定时器的引出接口； - 大部分USART引出接口

	- I2C1的引出接口； - SPI1的引出接口；


        输入输出快速切换

#define HD7279_DAT_OUT GPIOB->CRH=(GPIOB->CRH&(~(0x0000000F<<20)))|0x00000003<<20 //推挽输出
#define HD7279_DAT_IN GPIOB->CRH=(GPIOB->CRH&(~(0x0000000F<<20)))|0x00000004<<20 //浮空输入




